var documenterSearchIndex = {"docs":
[{"location":"performanceMetrics/#Performance-Metrics","page":"Performance Metrics","title":"Performance Metrics","text":"","category":"section"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"The following scripts were used to check errors and runtime.","category":"page"},{"location":"performanceMetrics/#Error-Calculations","page":"Performance Metrics","title":"Error Calculations","text":"","category":"section"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"Since parameter sets are identified up to permutation, the following finds the permutation that best reduces the error of the mixing coefficients and applies it to the means and covariances to compute their respective errors.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function computeError(w, true_means, true_covariances, mixing_coefficients, means, covariances, diagonal)\n    k = size(w)[1]\n    d = size(true_means)[2]\n\n    basis = 1:k\n\n    minimum_weight_error = (norm(w - mixing_coefficients), basis)\n    for i in 2:factorial(k)\n        permutation = nthperm(basis, i)\n        mixed_weights = Array{Float64}(undef, size(w))\n        for j in 1:k\n            mixed_weights[j, 1:end] = mixing_coefficients[permutation[j], 1:end]\n        end\n        weight_error = norm(mixed_weights - w)\n        (weight_error < minimum_weight_error[1]) && (minimum_weight_error = (weight_error, permutation))\n    end\n\n    permutation = minimum_weight_error[2]\n\n    final_mixing_coefficients = Array{Float64}(undef, size(mixing_coefficients))\n    final_means = Array{Float64}(undef, size(means))\n\n    if diagonal\n        final_covariances = []\n        for j in 1:k\n            final_mixing_coefficients[j] = mixing_coefficients[permutation[j]]\n            final_means[j, 1:end] = means[permutation[j], 1:end]\n            push!(final_covariances, covariances[permutation[j]][1:end, 1:end])\n        end\n    else\n    final_covariances = Array{Union{Float64}, 3}(undef, (k,d,d))\n        for j in 1:k\n            final_mixing_coefficients[j] = mixing_coefficients[permutation[j]]\n            final_means[j, 1:end] = means[permutation[j], 1:end]\n            final_covariances[j, 1:end, 1:end] = covariances[permutation[j], 1:end, 1:end]\n        end\n    end\n\n    mixing_error = norm(final_mixing_coefficients - w)\n    means_error = norm(final_means - true_means)\n    covariance_error = norm(final_covariances - true_covariances)\n\n    return (mixing_error, means_error, covariance_error)\nend","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"This is similar, but for Algorithm 2 from Estimating Gaussian Mixtures Using Sparse Polynomial Moment Systems all but the means are known so it merely permutes the means to find the minimum error permutation and then returns that error.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function computeErrorAlg2(true_mean, est_mean)\n    k = size(true_mean)[1]\n    d = size(true_mean)[2]\n\n    basis = 1:k\n\n    minimum_error = norm(true_mean - est_mean)\n    for i in 2:factorial(k)\n        permutation = nthperm(basis, i)\n        mixed_means = Array{Float64}(undef, size(true_mean))\n        for j in 1:k\n            mixed_means[j, 1:end] = est_mean[permutation[j], 1:end]\n        end\n        mean_error = norm(mixed_means - true_mean)\n        (mean_error < minimum_error) && (minimum_error = mean_error)\n    end\n\n    return minimum_error\nend","category":"page"},{"location":"performanceMetrics/#Tests","page":"Performance Metrics","title":"Tests","text":"","category":"section"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"The following tests performance while adding specified levels of noise to the denoised moments. This relies on the above listed computeError function.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function testNoise(d, k, diagonal, noise_levels, reps, known_mixing_coeffs)\n    passes = []\n    mix_errs = []\n    mean_errs = []\n    covar_errs = []\n    timings = []\n\n    for noise in noise_levels\n        passing = 0\n        mixing_error = 0\n        means_error = 0\n        covariance_error = 0\n        times = 0\n\n        for i in 1:reps\n            w, true_means, true_covariances = generateGaussians(d, k, diagonal)\n            if diagonal\n                true_first, true_diag = diagonalPerfectMoments(d, k, w, true_means, true_covariances)\n                num_moments = 3*k + (d-1)*(2*k+1)\n            else\n                true_first, true_diag, true_others = densePerfectMoments(d, k, w, true_means, true_covariances)\n                num_moments = 3*k + (d-1)*(2*k+1) + k*(d^2-d)/2\n            end\n\n            if noise>0\n                randomness = randn(Int64(num_moments))\n                randomness = noise/norm(randomness) * randomness\n\n                noisy_first = true_first + [0, randomness[1:3*k]...]\n                noisy_diag = true_diag + reshape(randomness[3*k+1:3*k + (d-1)*(2*k+1)], (d-1,2*k+1))\n\n                if !diagonal\n                    noisy_others = Dict{Vector{Int64}, Float64}()\n                    orig = []\n                    new = []\n                    counter = 3*k + (d-1)*(2*k+1) + 1\n                    for (key, moment) in true_others\n                        push!(orig, moment)\n                        push!(new, moment + randomness[counter])\n                        noisy_others[key] = moment + randomness[counter]\n                        counter += 1\n                    end\n                end\n            else\n                noisy_first = true_first\n                noisy_diag = true_diag\n                if !diagonal\n                    noisy_others = true_others\n                end\n            end\n\n            pass = false\n            if diagonal\n                if known_mixing_coeffs\n                    timing = @elapsed begin\n                        pass, (mixing_coefficients, means, covariances) = estimate_parameters(d, k, w, noisy_first, noisy_diag)\n                    end\n                else\n                    timing = @elapsed begin\n                        pass, (mixing_coefficients, means, covariances) = estimate_parameters(d, k, noisy_first, noisy_diag)\n                    end\n                end\n            else\n                if known_mixing_coeffs\n                    timing = @elapsed begin\n                        pass, (mixing_coefficients, means, covariances) = estimate_parameters(d, k, w, noisy_first, noisy_diag, noisy_others)\n                    end\n                else\n                    timing = @elapsed begin\n                        pass, (mixing_coefficients, means, covariances) = estimate_parameters(d, k, noisy_first, noisy_diag, noisy_others)\n                    end\n                end\n            end\n\n            if pass == true\n                passing += 1\n                (mix, mean, cov) = computeError(w, true_means, true_covariances, mixing_coefficients, means, covariances, diagonal)\n                mixing_error += mix\n                means_error += mean\n                covariance_error += cov\n                times += timing\n            end\n        end\n        push!(passes, passing)\n        if passing > 0\n            push!(mix_errs, mixing_error/passing)\n            push!(mean_errs, means_error/passing)\n            push!(covar_errs, covariance_error/passing)\n            push!(timings, times/passing)\n        else\n            push!(mix_errs, nothing)\n            push!(mean_errs, nothing)\n            push!(covar_errs, nothing)\n            push!(timings, nothing)\n        end\n        open(\"noise_test_d\" * string(d) * \"_k\" * string(k) * \"_diag\" * string(diagonal) * \"_knoww\" * string(known_mixing_coeffs) * \".txt\", \"w\") do file\n            write(file, \"reps: \" * string(reps) * \"\\nnoise levels: \" * string(noise_levels) * \"\\npasses: \" * string(passes) * \"\\naverage mixing coefficient error: \" * string(mix_errs) * \"\\naverage mean error: \" * string(mean_errs) * \"\\naverage covariance error: \" * string(covar_errs) * \"\\naverage time: \" * string(timings) * \"\\n\")\n        end\n        println(\"check\")\n    end\nend","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"Example of use:","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"k = 3\nd = 5\ndiag = true\nknown = false\ntestNoise(d, k, diag, [.1, .01, .001, .0001, 0], 10, known)","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"The following tests performance with 100 samples per parameter, cycling over dimensions to find candidate mixing coefficients if the solver is unsuccessful with prior mixing coefficient candidates.  This relies on the above listed computeError function.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function testSampleAlg2(d, k, reps)\n    num_params = k*d\n    num_samples = 200*num_params\n\n    passing = 0\n    means_error = 0\n    times = 0\n\n    w = (1/k)*ones(k)\n\n    for i in 1:reps\n        shared_cov = makeCovarianceMatrix(d, false)\n        true_mean = randn(k,d)\n\n        variances = Array{Float64, 3}(undef, (k,d,d))\n        for i in 1:k\n            variances[i, 1:end, 1:end] = copy(shared_cov)\n        end\n\n        sample = getSample(num_samples, w, true_mean, variances)\n        variances = []\n\n        m1, m2 = equalMixCovarianceKnown_moments(k, sample)\n\n        timing = @elapsed begin\n            pass, est_mean = estimate_parameters(k, shared_cov, m1, m2)\n        end\n        if pass == true\n            passing += 1\n            means_error += computeErrorAlg2(true_mean, est_mean)\n            times += timing\n        end\n    end\n\n    if passing > 0\n        means_error = means_error/passing\n        times = times/passing\n    else\n        means_error = nothing\n        times = nothing\n    end\n\n    open(\"alg2_sample_test_d\" * string(d) * \"_k\" * string(k) * \".txt\", \"w\") do file\n        write(file, \"reps: \" * string(reps) * \"\\npasses: \" * string(passing) * \"\\naverage mean error: \" * string(means_error) * \"\\naverage time: \" * string(times) * \"\\n\")\n    end\nend","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"Example of use:","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"k = 2\ndiagonal = true\nd = 10\nreps = 100\ntestSampleCycle(d, k, diagonal, reps)","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"The following tests performance of Algorithm 2 from Estimating Gaussian Mixtures Using Sparse Polynomial Moment Systems for denoised moments. This relies on the above listed computeErrorAlg2 function.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function testPerfectAlg2(d, k, reps)\n    passing = 0\n    means_error = 0\n    times = 0\n\n    for i in 1:reps\n        shared_cov = makeCovarianceMatrix(d, false)\n        true_mean = randn(k,d)\n        m1, m2 = equalMixCovarianceKnown_moments(k, true_mean, shared_cov)\n\n        timing = @elapsed begin\n            pass, est_mean = estimate_parameters(k, shared_cov, m1, m2)\n        end\n        if pass == true\n            passing += 1\n            means_error += computeErrorAlg2(true_mean, est_mean)\n            times += timing\n        end\n    end\n\n    if passing > 0\n        means_error = means_error/passing\n        times = times/passing\n    else\n        means_error = nothing\n        times = nothing\n    end\n\n    open(\"alg2_perfect_test_d\" * string(d) * \"_k\" * string(k) * \".txt\", \"w\") do file\n        write(file, \"reps: \" * string(reps) * \"\\npasses: \" * string(passing) * \"\\naverage mean error: \" * string(means_error) * \"\\naverage time: \" * string(times) * \"\\n\")\n    end\nend","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"The following tests performance of Algorithm 2 from Estimating Gaussian Mixtures Using Sparse Polynomial Moment Systems for sample moments with 200 samples per parameter. This relies on the above listed computeErrorAlg2 function.","category":"page"},{"location":"performanceMetrics/","page":"Performance Metrics","title":"Performance Metrics","text":"function testSampleAlg2(d, k, reps)\n    num_params = k*d\n    num_samples = 200*num_params\n\n    passing = 0\n    means_error = 0\n    times = 0\n\n    w = (1/k)*ones(k)\n\n    for i in 1:reps\n        shared_cov = makeCovarianceMatrix(d, false)\n        true_mean = randn(k,d)\n\n        variances = Array{Float64, 3}(undef, (k,d,d))\n        for i in 1:k\n            variances[i, 1:end, 1:end] = copy(shared_cov)\n        end\n\n        sample = getSample(num_samples, w, true_mean, variances)\n        variances = []\n\n        m1, m2 = equalMixCovarianceKnown_moments(k, sample)\n\n        timing = @elapsed begin\n            pass, est_mean = estimate_parameters(k, shared_cov, m1, m2)\n        end\n        if pass == true\n            passing += 1\n            means_error += computeErrorAlg2(true_mean, est_mean)\n            times += timing\n        end\n    end\n\n    if passing > 0\n        means_error = means_error/passing\n        times = times/passing\n    else\n        means_error = nothing\n        times = nothing\n    end\n\n    open(\"alg2_sample_test_d\" * string(d) * \"_k\" * string(k) * \".txt\", \"w\") do file\n        write(file, \"reps: \" * string(reps) * \"\\npasses: \" * string(passing) * \"\\naverage mean error: \" * string(means_error) * \"\\naverage time: \" * string(times) * \"\\n\")\n    end\nend","category":"page"},{"location":"#GMMParameterEstimation.jl-Documentation","page":"Home","title":"GMMParameterEstimation.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GMMParameterEstimation.jl is a package for estimating the parameters of Gaussian k-mixture models using the method of moments. It can potentially find the parameters for arbitrary k with known or unknown mixing coefficients.  However, since the number of possible solutions to the polynomial system that determines the first dimension parameters and mixing coefficients for k4 is unknown, for the unknown mixing coefficient case with k4 failure of the package to find the parameters might occur if an insufficient number of solutions to the system were found","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following code snippet will use the given moments to return an estimate of the parameters using the method of moments with unknown mixing coefficients and dense covariance matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GMMParameterEstimation\nd = 3\nk = 2\nfirst_moments = [1.0, -0.67, 2.44, -4.34, 17.4, -46.16, 201.67]\ndiagonal_moments = [-0.28 2.11 -2.46 15.29 -31.77; 0.4 4.25 3.88 54.75 59.10]\noff_diag_system = Dict{Vector{Int64}, Float64}([2, 1, 0] => 1.8506, [1, 0, 1] => -0.329, [2, 0, 1] => 0.0291, [0, 2, 1] => 1.5869, [1, 1, 0] => -1.374, [0, 1, 1] => -0.333)\nis_solution_found, (mixing_coefficients, means, covariances) = estimate_parameters(d, k, first_moments, diagonal_moments, off_diag_system)","category":"page"},{"location":"#Inputs:","page":"Home","title":"Inputs:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The number of dimensions d\nThe number of mixture components k\nOptional: A vector of mixing coefficients w with length k\nA list of the first 3k+1 moments (including moment 0) of the first dimension as first_moments\nA matrix where row i contains the first 2k+1 moments (not including moment 0) of the ith dimension as diagonal_moments\nOptional: A dictionary mapping the index of a mixed dimensional moment as a list of integers to the corresponding moment off_diag_system (See mixedMomentSystem for clarrification on which moments to include.)","category":"page"},{"location":"#Outputs:","page":"Home","title":"Outputs:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An indicator of success in finding the parameters is_solution_found\nA tuple of the parameters (mixing_coefficients, means, covariances) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following code snippet will generate the denoised moments necessary for parameter recovery from the given parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GMMParameterEstimation\n\nd=3\nk=2\ndiagonal = false\n\nmeans = [0.83 0.24 -1.53; 0.22 0.04 -0.71]\ncovariances = [0.8828527552401668 0.27735188899130847 1.6710529671002674; 2.257873093006253 -1.644707016523332 -0.533030022431624;;; 0.27735188899130847 1.2623673813995742 3.5270452552353238; -1.644707016523332 2.577324062116896 -0.5049891831614162;;; 1.6710529671002674 3.5270452552353238 16.696895556824817; -0.533030022431624 -0.5049891831614162 1.7733508773418585]\nmixing_coefficients = [.3, .7]\n\nif diagonal\n    true_first, true_diag = diagonalPerfectMoments(d, k, w, true_means, true_covariances)\nelse\n    true_first, true_diag, true_others = densePerfectMoments(d, k, w, true_means, true_covariances)\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Parameter-estimation","page":"Home","title":"Parameter estimation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main functionality of this package stems from ","category":"page"},{"location":"","page":"Home","title":"Home","text":"estimate_parameters","category":"page"},{"location":"#GMMParameterEstimation.estimate_parameters","page":"Home","title":"GMMParameterEstimation.estimate_parameters","text":"estimate_parameters(d::Integer, k::Integer, first::Vector{Float64}, second::Matrix{Float64}, last::Dict{Vector{Int64}, Float64}; method = \"recursive\")\n\nCompute an estimate for the parameters of a d-dimensional Gaussian k-mixture model from the moments.\n\nFor the unknown mixing coefficient dense covariance matrix case, first should be a list of moments 0 through 3k for the first dimension, second should be a matrix of moments 1 through 2k+1 for the remaining dimensions, and last should be a dictionary of the indices as lists of integers and the corresponding moments.\n\n\n\n\n\nestimate_parameters(d::Integer, k::Integer, w::Array{Float64}, first::Vector{Float64}, second::Matrix{Float64}, last::Dict{Vector{Int64}, Float64}; method = \"recursive\")\n\nCompute an estimate for the parameters of a d-dimensional Gaussian k-mixture model from the moments.\n\nFor the known mixing coefficient dense covariance matrix case, w should be a vector of the mixing coefficients first should be a list of moments 0 through 3k for the first dimension, second should be a matrix of moments 1 through 2k+1 for the remaining dimensions, and last should be a dictionary of the indices as lists of integers and the corresponding moments.\n\n\n\n\n\nestimate_parameters(d::Integer, k::Integer, first::Vector{Float64}, second::Matrix{Float64})\n\nCompute an estimate for the parameters of a d-dimensional Gaussian k-mixture model from the moments.\n\nFor the unknown mixing coefficient diagonal covariance matrix case, first should be a list of moments 0 through 3k for the first dimension, and second should be a matrix of moments 1 through 2k+1 for the remaining dimensions.\n\n\n\n\n\nestimate_parameters(d::Integer, k::Integer, w::Array{Float64}, first::Vector{Float64}, second::Matrix{Float64})\n\nCompute an estimate for the parameters of a d-dimensional Gaussian k-mixture model from the moments.\n\nFor the known mixing coefficient diagonal covariance matrix case, w should be a vector of the mixing coefficients first should be a list of moments 0 through 3k for the first dimension, and second should be a matrix of moments 1 through 2k+1 for the remaining dimensions.\n\n\n\n\n\nestimate_parameters(k::Integer, shared_cov::Matrix{Float64}, first::Vector{Float64}, second::Matrix{Float64}; method = \"recursive\")\n\nCompute an estimate for the means of a Gaussian k-mixture model with equal mixing coefficients and known shared covariances from the moments.\n\nThe shared covariance matrix shared_cov will determine the dimension. Then first should be a list of moments 0 through k for the first dimension, second should be a matrix of moments m_je_1+e_i for j in 0 to k-1 and i in 2 to d as a matrix where d is the dimension, i varies across rows, and j varies down columns.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"which computes the parameter recovery using Algorithm 1 from Estimating Gaussian Mixtures Using Sparse Polynomial Moment Systems.  Note that the unknown mixing coefficient cases with kin234 load a set of generic moments and the corresponding solutions to the first 1-D polynomial system from sys1_k2.jld2, sys1_k3.jld2, or sys1_k4.jld2 for a slight speedup.  If k is not specified, k=1 will be assumed, and the resulting polynomial system will be solved explicitly and directly.   ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In one dimension, for a random variable X with density f define the ith moment as  m_i=EX^i=int x^if(x)dx.   For a Gaussian mixture model, this results in a polynomial in the parameters.  For a sample y_1y_2dotsy_N, define the ith sample moment as  overlinem_i=frac1Nsum_j=1^N y_j^i.   The sample moments approach the true moments as Nrightarrowinfty, so by setting the polynomials equal to the empirical moments, we can then solve the polynomial system to recover the parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a multivariate random variable X with density f_X define the moments as  m_i_1dotsi_n = EX_1^i_1cdots X_n^i_n = intcdotsint x_1^i_1cdots x_n^i_nf_X(x_1dotsx_n)dx_1cdots dx_n  and the empirical moments as  overlinem_i_1dotsi_n = frac1Nsum_j=1^Ny_j_1^i_1cdots y_j_n^i_n.   And again, by setting the polynomials equal to the empirical moments, we can then solve the system of polynomials to recover the parameters.  However, choosing which moments becomes more complicated.  If we know the mixing coefficients, we can use the first 2k+1 moments of each dimension to find the means and the diagonal entries of the covariance matrices.  If we do not know the mixing coefficients, we need the first 3k moments of the first dimension to also find the mixing coefficients.  See mixedMomentSystem for which moments to include to fill in the off-diagonals of the covariance matrices if needed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"On a standard laptop we have successfully recovered parameters with unknown mixing coefficients for kleq 4 and known mixing coefficients for kleq 5, with dleq 10^5 for the diagonal covariance case and dleq 50 for the dense covariance case.  Higher k values or higher d values have led to issues with running out of RAM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"One potential difficulty in estimating the mixing coefficients is the resulting dependence on higher moments in the first dimension.  In sample data, if another dimension leads to more accurate moments, using that dimension to recover mixing coefficients and then proceeding can address this difficulty.  The following function was designed for this purpose.  Note that it can either be provided with an d x n sample, or a d x 3k+1 array of moments 0 through 3k for each dimension, augmented by a dictionary of the off-diagonal moments if seeking non-diagonal covariance matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"dimension_cycle","category":"page"},{"location":"#GMMParameterEstimation.dimension_cycle","page":"Home","title":"GMMParameterEstimation.dimension_cycle","text":"dimension_cycle(d::Integer, k::Integer, cycle_moments::Array{Float64}, indexes::Dict{Vector{Int64}, Float64}; method = \"recursive\")\n\nCycle over the dimensions of cycle_moments to find candidate mixing coefficients, then solve for parameters based on those.\n\nThis will take longer than estimate_parameters since it does multiple tries.  Will try each dimension to attempt to find mixing coefficients, and if found will try to solve for parameters.  Returns pass = false if no dimension results in mixing coefficients that allow for a solution.  cycle_moments should be an array of the 0 through 3k moments for each dimension. If no indexes is given, assumes diagonal covariance matrices and a method should not be specified.\n\n\n\n\n\n","category":"function"},{"location":"#Checking-Input-Formatting","page":"Home","title":"Checking Input Formatting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To check you are formatting your inputs correctly, we have included","category":"page"},{"location":"","page":"Home","title":"Home","text":"checkInputs","category":"page"},{"location":"#GMMParameterEstimation.checkInputs","page":"Home","title":"GMMParameterEstimation.checkInputs","text":"fix doc strings if this works\n\ncheckInputs(d::Integer, k::Integer, first::Vector{Float64}, second::Matrix{Float64}, last::Dict{Vector{Int64}, Float64}, method)\n\nReturns true if the inputs are the right format for estimate_parameters and an error otherwise.\n\n\n\n\n\ncheckInputs(d::Integer, k::Integer, w::Vector{Float64}, first::Vector{Float64}, second::Matrix{Float64}, last::Dict{Vector{Int64}, Float64}, method)\n\n\n\n\n\ncheckInputs(d::Integer, k::Integer, first::Vector{Float64}, second::Matrix{Float64})\n\n\n\n\n\ncheckInputs(d::Integer, k::Integer, w::Vector{Float64}, first::Vector{Float64}, second::Matrix{Float64})\n\n\n\n\n\ncheckInputs(d::Integer, k::Integer, shared_cov::Matrix{Float64}, first::Vector{Float64}, second::Matrix{Float64}, method)\n\n\n\n\n\n","category":"function"},{"location":"#Generate-and-sample-from-Gaussian-Mixture-Models","page":"Home","title":"Generate and sample from Gaussian Mixture Models","text":"","category":"section"},{"location":"#Generation","page":"Home","title":"Generation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"makeCovarianceMatrix","category":"page"},{"location":"#GMMParameterEstimation.makeCovarianceMatrix","page":"Home","title":"GMMParameterEstimation.makeCovarianceMatrix","text":"makeCovarianceMatrix(d::Integer, diagonal::Bool)\n\nGenerate random dxd covariance matrix.\n\nIf diagonal==true, returns a diagonal covariance matrix.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Note that the entries of the resulting covariance matrices are generated from a normal distribution centered at 0 with variance 1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"generateGaussians","category":"page"},{"location":"#GMMParameterEstimation.generateGaussians","page":"Home","title":"GMMParameterEstimation.generateGaussians","text":"generateGaussians(d::Integer, k::Integer, diagonal::Bool)\n\nGenerate means and covariances for k Gaussians with dimension d.\n\ndiagonal should be true for spherical case, and false for dense covariance matrices.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"The parameters are returned as a tuple, with weights in a 1D vector, means as a k x d array, and variances as a k x d x d array if diagonal is false or as a list of Diagonal{Float64, Vector{Float64}} if diagonal is true to save memory.  Note that each entry of each parameter is generated from a normal distribution centered at 0 with variance 1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"getSample","category":"page"},{"location":"#GMMParameterEstimation.getSample","page":"Home","title":"GMMParameterEstimation.getSample","text":"getSample(numb::Integer, w::Vector{Float64}, means::Matrix{Float64}, covariances::Vector)\n\nGenerate a Gaussian mixture model sample with numb entries, mixing coefficients w, means means, and covariances covariances.\n\n\n\n\n\ngetSample(numb::Integer, w::Vector{Float64}, means::Matrix{Float64}, covariances::Array{Float64, 3})\n\nGenerate a Gaussian mixture model sample with numb entries, mixing coefficients w, means means, and covariances covariances.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"This relies on the Distributions package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Computing-moments","page":"Home","title":"Computing moments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"sampleMoments\ndiagonalPerfectMoments\ndensePerfectMoments\nmoments_for_cycle\nequalMixCovarianceKnown_moments","category":"page"},{"location":"#GMMParameterEstimation.sampleMoments","page":"Home","title":"GMMParameterEstimation.sampleMoments","text":"sampleMoments(sample::Matrix{Float64}, k; diagonal = false)\n\nUse the sample to compute the moments necessary for parameter estimation using method of moments with general covariance matrices and mixing coefficients.\n\nReturns moments 0 to 3k for the first dimension, moments 1 through 2k+1 for the other dimensions as a matrix, and a dictionary with indices and moments for the off-diagonal system if diagonal is false.\n\n\n\n\n\n","category":"function"},{"location":"#GMMParameterEstimation.diagonalPerfectMoments","page":"Home","title":"GMMParameterEstimation.diagonalPerfectMoments","text":"diagonalPerfectMoments(d, k, w, true_means, true_covariances)\n\nUse the given parameters to compute the exact moments necessary for parameter estimation with diagonal covariance matrices.\n\nReturns moments 0 to 3k for the first dimension, and moments 1 through 2k+1 for the other dimensions as a matrix.\n\n\n\n\n\n","category":"function"},{"location":"#GMMParameterEstimation.densePerfectMoments","page":"Home","title":"GMMParameterEstimation.densePerfectMoments","text":"densePerfectMoments(d, k, w, true_means, true_covariances)\n\nUse the given parameters to compute the exact moments necessary for parameter estimation with dense covariance matrices.\n\nReturns moments 0 to 3k for the first dimension, moments 1 through 2k+1 for the other dimensions as a matrix, and a dictionary with indices and moments for the off-diagonal system.\n\n\n\n\n\n","category":"function"},{"location":"#GMMParameterEstimation.moments_for_cycle","page":"Home","title":"GMMParameterEstimation.moments_for_cycle","text":"moments_for_cycle(d, k, w, means, covars, diagonal)\n\nCalculate 0 through 3k+1 denoised moments for every dimension.\n\nUsed as input for cycling over the dimensions to find candidate mixing coefficients.\n\n\n\n\n\n","category":"function"},{"location":"#GMMParameterEstimation.equalMixCovarianceKnown_moments","page":"Home","title":"GMMParameterEstimation.equalMixCovarianceKnown_moments","text":"equalMixCovarianceKnown_moments(k, mean, shared_cov)\n\nUse the given parameters to compute the exact moments necessary for parameter estimation with equal mixing coefficients and shared known covariances.\n\nReturns moments 0 to k for the first dimension, and moments math m\\_{je\\_1+e\\_i} for j in 0 to k-1 and i in 2 to d as a matrix where d is the dimension, i varies across rows, and j varies down columns.\n\n\n\n\n\nequalMixCovarianceKnown_moments(k, sample)\n\nUse the given parameters to compute the sample moments necessary for parameter estimation with equal mixing coefficients and shared known covariances.\n\nReturns moments 0 to k for the first dimension, and moments m{je1+e_i} for j in 0 to k-1 and i in 2 to d as a matrix where d is the dimension, i varies across rows, and j varies down columns.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"These expect parameters to be given with weights in a 1D vector, means as a k x d array, and covariances as a k x d x d array for dense covariance matrices or as a list of diagonal matrices for diagonal covariance matrices.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Build-the-polynomial-systems","page":"Home","title":"Build the polynomial systems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"build1DSystem","category":"page"},{"location":"#GMMParameterEstimation.build1DSystem","page":"Home","title":"GMMParameterEstimation.build1DSystem","text":"build1DSystem(k::Integer, m::Integer)\n\nBuild the polynomial system for a mixture of 1D Gaussians where 'm'-1 is the highest desired moment and the mixing coefficients are unknown.\n\n\n\n\n\nbuild1DSystem(k::Integer, m::Integer, a::Union{Vector{Float64}, Vector{Variable}})\n\nBuild the polynomial system for a mixture of 1D Gaussians where 'm'-1 is the highest desired moment, and a is a vector of the mixing coefficients.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"This uses the usual recursive formula for moments of a univariate Gaussian in terms of the mean and variance, and then takes a convex combination with either variable mixing coefficients or the provided mixing coefficients.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"selectSol","category":"page"},{"location":"","page":"Home","title":"Home","text":"Statistically significant means has positive variances here.  This is used to select which solution from the parameter homotopy will be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"tensorPower","category":"page"},{"location":"","page":"Home","title":"Home","text":"convert_indexing","category":"page"},{"location":"","page":"Home","title":"Home","text":"To our knowledge, the only closed form formula for the mixed dimensional moments of a multivariate Gaussian is that provided by Joao M. Pereira, Joe Kileel, and Tamara G. Kolda in Tensor Moments of Gaussian Mixture Models: Theory and Applications.  However, the tensor moments are indexed in a different way than the multivariate moment notation we used.  Let  m_a_1cdots a_n be a d-th order multivariate moment and let M_i_1cdots i_d^(d) be an entry of the d-th order tensor moment.  Then m_a_1cdots a_n=M_i_1cdots i_d^(d) where  a_j=i_k=j.  Note that due to symmetry, the indexing of the tensor moment is non-unique.  For example, m_102 = M_133^(3)=M_331^(3)=M_313^(3)=m_102.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"mixedMomentSystem","category":"page"},{"location":"","page":"Home","title":"Home","text":"The final step in our method of moments parameter recovery for non-diagonal covariance matrices is building and solving a system of N=frack2(d^2-d) linear equations in the same number of unknowns to fill in the off diagonal.  The polynomial for m_a_1cdots a_n is linear if all but two a_i=0 and at least one a_1=1.  There are n^2-n of these for each order geq2, so we need these equations for up to lceil frack2rceil-th order.  These moments should be provided to the solver using minimal possible degree, and if only half the possible moments for a degree are necessary (k/2 is even) provide the moments with higher power in earlier dimension, e.g. use [2,1,0] instead of [1,2,0].","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: the polynomial is still linear when 3 a_i=1 and the rest of the a_i are 0 but this complicates generating the system so we did not include those.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Referring back to Pereira et al. for a closed form method of generating the necessary moment polynomials, we generate the linear system using the already computed mixing coefficients, means, and diagonals of the covariances, and return it as a dictionary of index=>polynomial pairs that can then be matched with the corresponding moments.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
